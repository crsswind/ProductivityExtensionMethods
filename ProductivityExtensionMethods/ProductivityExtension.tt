<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ output extension=".methods.tt" #>
\<#@ template debug="false" hostspecific="true" language="C#" \#>
\<#@ assembly name="System.Core" \#>
\<#@ assembly name="EnvDte" \#>
\<#@ assembly name="System.Xml" \#>
\<#@ assembly name="System.Xml.Linq" \#>
\<#@ import namespace="System.IO" \#>
\<#@ import namespace="System.Linq" \#>
\<#@ import namespace="System.Xml.Linq" \#>
\<#@ import namespace="System.Text" \#>
\<#@ import namespace="System.Text.RegularExpressions" \#>
\<#@ import namespace="System.Collections.Generic" \#>
\<#@ import namespace="Microsoft.VisualStudio.TextTemplating" \#>
\<#@ output extension=".cs" \#>
\<#
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Modify next section in order to ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~To include the extension methods in the generated code.~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<#
 string extensionMethodsSourceCode = PreprocessCode(this.Host.ResolvePath("AllExtensions.cs"));

 if(extensionMethodsSourceCode==null)
	throw new Exception("Cannot read the source code for extension, or preprocess it.");
 

 
 Regex regionFinderRegex=new Regex(@"(?=#region\s+(?<RegionName>[^\r\n]+))(?:(?<ltparen>(?(content)(?(ltparen)#region\s+[^\r\n]*\r\n|)|#region\s+[^\r\n]*\r\n))|(?<content-ltparen>#endregion)|(?(ltparen)(?(#region\s+[^\r\n]*\r\n|#endregion)|.+?)|))+",  RegexOptions.IgnoreCase|  RegexOptions.Singleline|  RegexOptions.ExplicitCapture);
 var  regionMatches= regionFinderRegex.Matches(extensionMethodsSourceCode)
									  .Cast<Match>()
									  .Select(it=>(
													ConfigFlag: it.Groups["RegionName"].Value.Replace(" ",""),
													Code: it.Groups["content"].Value,
													StartIndex: it.Index,
													EndIndex: it.Index + it.Length
												  )
											  )
									  .ToList();

 foreach(var region in regionMatches)
 {
#>
bool <#=region.ConfigFlag#> = false;
<#}#>
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~DO NOT MODIFY AFTER THIS SECTION~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~The changes will be overwritten when nuget package is restored~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~Use partial classes to add extra functionality~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//ToolsVersion:VersionPlaceholder{D8B1B561-500C-4086-91AA-0714457205DA}
bool isNullableCompatible= IsNullableCompatible();
\#>
<#
	string startCode = extensionMethodsSourceCode.Substring(0,regionMatches[0].StartIndex);
	startCode = startCode.Replace("namespace ProductivityExtensionMethods","namespace \<#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData(\"NamespaceHint\")\#>");
	startCode = MakeNullableSyntaxConditional(startCode);

    Write(startCode);

#>
<#foreach(var region in regionMatches)
{
#>\<#if(<#=region.ConfigFlag#>)
{
\#>
<#=MakeNullableSyntaxConditional(region.Code)#>
\<#
}
\#>
<#}#><#=MakeNullableSyntaxConditional(extensionMethodsSourceCode.Substring(regionMatches.Last().EndIndex))#>

\<#+
private bool IsNullableCompatible()
{
	EnvDTE.DTE visualStudio = (EnvDTE.DTE)((IServiceProvider)this.Host).GetCOMService(typeof(EnvDTE.DTE));
	Regex regEx = new Regex(@"^\d+(\.\d+)", RegexOptions.ExplicitCapture);

	Match mtch = regEx.Match(visualStudio.Version);

	return mtch.Success && float.Parse(mtch.Value) >= 16f;
}
\#>
<#+
private string PreprocessCode(string codePath)
{

	string executablePath = null;
	
	foreach(var it in new[]{"Release","Debug"})
	{
		try
		{
		  executablePath = this.Host.ResolvePath(@$"..\CodePreprocessor\bin\{it}\netcoreapp3.0\CodePreprocessor.exe");
		  if(File.Exists(executablePath))
				break;
		}
		catch
		{}
	}
			
    if(executablePath == null)
		throw new ApplicationException("Cannot find the preprocessor executable. Make sure that the preprocessor project is built.");

	try
	{
    ProcessStartInfo psi = new ProcessStartInfo(executablePath, codePath);

    psi.CreateNoWindow = true;
    psi.RedirectStandardOutput = true;
    psi.UseShellExecute = false;
	psi.WorkingDirectory = System.IO.Directory.GetCurrentDirectory();
	
    Process p = Process.Start(psi);

    string s = p.StandardOutput.ReadToEnd();

    p.WaitForExit();

    if (p.ExitCode != 0)
        return null;

    return s;
	}
	catch
	{
	 throw new Exception(executablePath);
	}
}

private string MakeNullableSyntaxConditional(string code)
{
	Regex nullableRegex = new Regex(@"/\*Start:nullableref\*/(?<NullableSyntax>.+?)/\*End:nullableref\*/",RegexOptions.Singleline|  RegexOptions.ExplicitCapture);

	return nullableRegex.Replace(code, mtch => @"\<#if (isNullableCompatible){\#>" + mtch.Groups["NullableSyntax"].Value + @"\<#}\#>");
}
#>